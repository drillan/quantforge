"""QuantForge models module - Type-safe wrapper for Rust implementation.

This module provides fully typed interfaces to the Rust-based option pricing models,
ensuring complete type safety and IDE support.
"""

from dataclasses import dataclass

import numpy as np
from numpy.typing import ArrayLike, NDArray

# Import the Rust module
try:
    from . import quantforge

    _rust_models = quantforge.models  # type: ignore[attr-defined]
except ImportError:
    # Fallback for development
    import quantforge

    _rust_models = quantforge.models  # type: ignore[attr-defined]

# ===== Data Classes =====


@dataclass
class PyGreeks:
    """Greeks structure for option sensitivities."""

    delta: float
    gamma: float
    vega: float
    theta: float
    rho: float


@dataclass
class MertonGreeks(PyGreeks):
    """Greeks structure for Merton model with dividend sensitivity."""

    dividend_rho: float


@dataclass
class AmericanGreeks(PyGreeks):
    """Greeks structure for American options with dividend sensitivity."""

    dividend_rho: float


# ===== Black-Scholes Functions =====


def call_price(s: float, k: float, t: float, r: float, sigma: float) -> float:
    """Calculate European call option price using Black-Scholes model.

    Args:
        s: Spot price of the underlying asset
        k: Strike price of the option
        t: Time to maturity (in years)
        r: Risk-free interest rate
        sigma: Volatility of the underlying asset

    Returns:
        Call option price

    Raises:
        ValueError: If inputs are outside valid ranges
    """
    return float(_rust_models.call_price(s, k, t, r, sigma))


def put_price(s: float, k: float, t: float, r: float, sigma: float) -> float:
    """Calculate European put option price using Black-Scholes model.

    Args:
        s: Spot price of the underlying asset
        k: Strike price of the option
        t: Time to maturity (in years)
        r: Risk-free interest rate
        sigma: Volatility of the underlying asset

    Returns:
        Put option price

    Raises:
        ValueError: If inputs are outside valid ranges
    """
    return float(_rust_models.put_price(s, k, t, r, sigma))


def call_price_batch(
    spots: ArrayLike,
    strikes: float | ArrayLike = 100.0,
    times: float | ArrayLike = 1.0,
    rates: float | ArrayLike = 0.05,
    sigmas: float | ArrayLike = 0.2,
) -> NDArray[np.float64]:
    """Calculate call option prices for multiple inputs (batch processing).

    Supports NumPy-style broadcasting for all parameters.

    Args:
        spots: Spot prices (array or scalar)
        strikes: Strike prices (array or scalar)
        times: Times to maturity (array or scalar)
        rates: Risk-free rates (array or scalar)
        sigmas: Volatilities (array or scalar)

    Returns:
        Array of call option prices
    """
    return np.array(_rust_models.call_price_batch(spots, strikes, times, rates, sigmas), dtype=np.float64)


def put_price_batch(
    spots: ArrayLike,
    strikes: float | ArrayLike = 100.0,
    times: float | ArrayLike = 1.0,
    rates: float | ArrayLike = 0.05,
    sigmas: float | ArrayLike = 0.2,
) -> NDArray[np.float64]:
    """Calculate put option prices for multiple inputs (batch processing).

    Supports NumPy-style broadcasting for all parameters.

    Args:
        spots: Spot prices (array or scalar)
        strikes: Strike prices (array or scalar)
        times: Times to maturity (array or scalar)
        rates: Risk-free rates (array or scalar)
        sigmas: Volatilities (array or scalar)

    Returns:
        Array of put option prices
    """
    return np.array(_rust_models.put_price_batch(spots, strikes, times, rates, sigmas), dtype=np.float64)


def greeks(
    s: float,
    k: float,
    t: float,
    r: float,
    sigma: float,
    is_call: bool = True,
) -> PyGreeks:
    """Calculate option Greeks (sensitivities).

    Args:
        s: Spot price of the underlying asset
        k: Strike price of the option
        t: Time to maturity (in years)
        r: Risk-free interest rate
        sigma: Volatility of the underlying asset
        is_call: True for call option, False for put option

    Returns:
        PyGreeks object containing delta, gamma, vega, theta, rho
    """
    result = _rust_models.greeks(s, k, t, r, sigma, is_call)
    return result  # type: ignore[no-any-return]


def greeks_batch(
    spots: ArrayLike,
    strikes: float | ArrayLike,
    times: float | ArrayLike,
    rates: float | ArrayLike,
    sigmas: float | ArrayLike,
    is_calls: float | ArrayLike,
) -> dict[str, NDArray[np.float64]]:
    """Calculate Greeks for multiple inputs (batch processing).

    Args:
        spots: Spot prices (array or scalar)
        strikes: Strike prices (array or scalar)
        times: Times to maturity (array or scalar)
        rates: Risk-free rates (array or scalar)
        sigmas: Volatilities (array or scalar)
        is_calls: Option types (1.0 for call, 0.0 for put)

    Returns:
        Dictionary with keys 'delta', 'gamma', 'vega', 'theta', 'rho',
        each containing an array of values
    """
    return _rust_models.greeks_batch(spots, strikes, times, rates, sigmas, is_calls)  # type: ignore[no-any-return]


def implied_volatility(
    price: float,
    s: float,
    k: float,
    t: float,
    r: float,
    is_call: bool = True,
    initial_guess: float | None = None,
) -> float:
    """Calculate implied volatility from option price.

    Args:
        price: Option market price
        s: Spot price of the underlying asset
        k: Strike price of the option
        t: Time to maturity (in years)
        r: Risk-free interest rate
        is_call: True for call option, False for put option
        initial_guess: Initial volatility guess (optional)

    Returns:
        Implied volatility

    Raises:
        ValueError: If price is outside valid bounds
        RuntimeError: If convergence fails
    """
    return float(_rust_models.implied_volatility(price, s, k, t, r, is_call, initial_guess))


def implied_volatility_batch(
    prices: ArrayLike,
    spots: float | ArrayLike,
    strikes: float | ArrayLike,
    times: float | ArrayLike,
    rates: float | ArrayLike,
    is_calls: float | ArrayLike,
) -> NDArray[np.float64]:
    """Calculate implied volatilities for multiple options.

    Args:
        prices: Option market prices
        spots: Spot prices (array or scalar)
        strikes: Strike prices (array or scalar)
        times: Times to maturity (array or scalar)
        rates: Risk-free rates (array or scalar)
        is_calls: Option types (1.0 for call, 0.0 for put)

    Returns:
        Array of implied volatilities
    """
    return np.array(
        _rust_models.implied_volatility_batch(prices, spots, strikes, times, rates, is_calls), dtype=np.float64
    )


# ===== Submodule Classes =====


class Black76Module:
    """Black76 model for futures options."""

    @staticmethod
    def call_price(f: float, k: float, t: float, r: float, sigma: float) -> float:
        """Calculate call option price on futures."""
        return float(_rust_models.black76.call_price(f, k, t, r, sigma))

    @staticmethod
    def put_price(f: float, k: float, t: float, r: float, sigma: float) -> float:
        """Calculate put option price on futures."""
        return float(_rust_models.black76.put_price(f, k, t, r, sigma))

    @staticmethod
    def call_price_batch(
        forwards: ArrayLike,
        strikes: float | ArrayLike,
        times: float | ArrayLike,
        rates: float | ArrayLike,
        sigmas: float | ArrayLike,
    ) -> NDArray[np.float64]:
        """Calculate call prices for multiple futures."""
        return np.array(
            _rust_models.black76.call_price_batch(forwards, strikes, times, rates, sigmas), dtype=np.float64
        )

    @staticmethod
    def put_price_batch(
        forwards: ArrayLike,
        strikes: float | ArrayLike,
        times: float | ArrayLike,
        rates: float | ArrayLike,
        sigmas: float | ArrayLike,
    ) -> NDArray[np.float64]:
        """Calculate put prices for multiple futures."""
        return np.array(_rust_models.black76.put_price_batch(forwards, strikes, times, rates, sigmas), dtype=np.float64)

    @staticmethod
    def greeks(
        f: float,
        k: float,
        t: float,
        r: float,
        sigma: float,
        is_call: bool = True,
    ) -> PyGreeks:
        """Calculate Greeks for futures option."""
        return _rust_models.black76.greeks(f, k, t, r, sigma, is_call)  # type: ignore[no-any-return]

    @staticmethod
    def greeks_batch(
        forwards: ArrayLike,
        strikes: float | ArrayLike,
        times: float | ArrayLike,
        rates: float | ArrayLike,
        sigmas: float | ArrayLike,
        is_calls: float | ArrayLike,
    ) -> dict[str, NDArray[np.float64]]:
        """Calculate Greeks for multiple futures options."""
        return _rust_models.black76.greeks_batch(forwards, strikes, times, rates, sigmas, is_calls)  # type: ignore[no-any-return]

    @staticmethod
    def implied_volatility(
        price: float,
        f: float,
        k: float,
        t: float,
        r: float,
        is_call: bool = True,
        initial_guess: float | None = None,
    ) -> float:
        """Calculate implied volatility for futures option."""
        return float(_rust_models.black76.implied_volatility(price, f, k, t, r, is_call, initial_guess))

    @staticmethod
    def implied_volatility_batch(
        prices: ArrayLike,
        forwards: float | ArrayLike,
        strikes: float | ArrayLike,
        times: float | ArrayLike,
        rates: float | ArrayLike,
        is_calls: float | ArrayLike,
    ) -> NDArray[np.float64]:
        """Calculate implied volatilities for multiple futures options."""
        return np.array(
            _rust_models.black76.implied_volatility_batch(prices, forwards, strikes, times, rates, is_calls),
            dtype=np.float64,
        )


class MertonModule:
    """Merton model with dividend yield."""

    @staticmethod
    def call_price(s: float, k: float, t: float, r: float, q: float, sigma: float) -> float:
        """Calculate call option price with dividends."""
        return float(_rust_models.merton.call_price(s, k, t, r, q, sigma))

    @staticmethod
    def put_price(s: float, k: float, t: float, r: float, q: float, sigma: float) -> float:
        """Calculate put option price with dividends."""
        return float(_rust_models.merton.put_price(s, k, t, r, q, sigma))

    @staticmethod
    def call_price_batch(
        spots: ArrayLike,
        strikes: float | ArrayLike,
        times: float | ArrayLike,
        rates: float | ArrayLike,
        dividends: float | ArrayLike,
        sigmas: float | ArrayLike,
    ) -> NDArray[np.float64]:
        """Calculate call prices with dividends for multiple inputs."""
        return np.array(
            _rust_models.merton.call_price_batch(spots, strikes, times, rates, dividends, sigmas), dtype=np.float64
        )

    @staticmethod
    def put_price_batch(
        spots: ArrayLike,
        strikes: float | ArrayLike,
        times: float | ArrayLike,
        rates: float | ArrayLike,
        dividends: float | ArrayLike,
        sigmas: float | ArrayLike,
    ) -> NDArray[np.float64]:
        """Calculate put prices with dividends for multiple inputs."""
        return np.array(
            _rust_models.merton.put_price_batch(spots, strikes, times, rates, dividends, sigmas), dtype=np.float64
        )

    @staticmethod
    def greeks(
        s: float,
        k: float,
        t: float,
        r: float,
        q: float,
        sigma: float,
        is_call: bool = True,
    ) -> MertonGreeks:
        """Calculate Greeks including dividend sensitivity."""
        result = _rust_models.merton.greeks(s, k, t, r, q, sigma, is_call)
        return result  # type: ignore[no-any-return]  # Already returns MertonGreeks from Rust

    @staticmethod
    def greeks_batch(
        spots: ArrayLike,
        strikes: float | ArrayLike,
        times: float | ArrayLike,
        rates: float | ArrayLike,
        dividends: float | ArrayLike,
        sigmas: float | ArrayLike,
        is_calls: float | ArrayLike,
    ) -> dict[str, NDArray[np.float64]]:
        """Calculate Greeks with dividends for multiple inputs."""
        return _rust_models.merton.greeks_batch(spots, strikes, times, rates, dividends, sigmas, is_calls)  # type: ignore[no-any-return]

    @staticmethod
    def implied_volatility(
        price: float,
        s: float,
        k: float,
        t: float,
        r: float,
        q: float,
        is_call: bool = True,
        initial_guess: float | None = None,
    ) -> float:
        """Calculate implied volatility with dividends."""
        return float(_rust_models.merton.implied_volatility(price, s, k, t, r, q, is_call, initial_guess))

    @staticmethod
    def implied_volatility_batch(
        prices: ArrayLike,
        spots: float | ArrayLike,
        strikes: float | ArrayLike,
        times: float | ArrayLike,
        rates: float | ArrayLike,
        dividends: float | ArrayLike,
        is_calls: float | ArrayLike,
    ) -> NDArray[np.float64]:
        """Calculate implied volatilities with dividends for multiple inputs."""
        return np.array(
            _rust_models.merton.implied_volatility_batch(prices, spots, strikes, times, rates, dividends, is_calls),
            dtype=np.float64,
        )


class AmericanModule:
    """American option model with early exercise."""

    @staticmethod
    def call_price(s: float, k: float, t: float, r: float, q: float, sigma: float) -> float:
        """Calculate American call option price."""
        return float(_rust_models.american.call_price(s, k, t, r, q, sigma))

    @staticmethod
    def put_price(s: float, k: float, t: float, r: float, q: float, sigma: float) -> float:
        """Calculate American put option price."""
        return float(_rust_models.american.put_price(s, k, t, r, q, sigma))

    @staticmethod
    def call_price_batch(
        spots: ArrayLike,
        strikes: float | ArrayLike,
        times: float | ArrayLike,
        rates: float | ArrayLike,
        dividends: float | ArrayLike,
        sigmas: float | ArrayLike,
    ) -> NDArray[np.float64]:
        """Calculate American call prices for multiple inputs."""
        return np.array(
            _rust_models.american.call_price_batch(spots, strikes, times, rates, dividends, sigmas), dtype=np.float64
        )

    @staticmethod
    def put_price_batch(
        spots: ArrayLike,
        strikes: float | ArrayLike,
        times: float | ArrayLike,
        rates: float | ArrayLike,
        dividends: float | ArrayLike,
        sigmas: float | ArrayLike,
    ) -> NDArray[np.float64]:
        """Calculate American put prices for multiple inputs."""
        return np.array(
            _rust_models.american.put_price_batch(spots, strikes, times, rates, dividends, sigmas), dtype=np.float64
        )

    @staticmethod
    def greeks(
        s: float,
        k: float,
        t: float,
        r: float,
        q: float,
        sigma: float,
        is_call: bool = False,
    ) -> AmericanGreeks:
        """Calculate American option Greeks."""
        result = _rust_models.american.greeks(s, k, t, r, q, sigma, is_call)
        return result  # type: ignore[no-any-return]  # Already returns AmericanGreeks from Rust

    @staticmethod
    def greeks_batch(
        spots: ArrayLike,
        strikes: float | ArrayLike,
        times: float | ArrayLike,
        rates: float | ArrayLike,
        dividends: float | ArrayLike,
        sigmas: float | ArrayLike,
        is_calls: float | ArrayLike,
    ) -> dict[str, NDArray[np.float64]]:
        """Calculate American Greeks for multiple inputs."""
        return _rust_models.american.greeks_batch(spots, strikes, times, rates, dividends, sigmas, is_calls)  # type: ignore[no-any-return]

    @staticmethod
    def implied_volatility(
        price: float,
        s: float,
        k: float,
        t: float,
        r: float,
        q: float,
        is_call: bool = False,
        initial_guess: float | None = None,
    ) -> float:
        """Calculate American implied volatility."""
        return float(_rust_models.american.implied_volatility(price, s, k, t, r, q, is_call, initial_guess))

    @staticmethod
    def implied_volatility_batch(
        prices: ArrayLike,
        spots: float | ArrayLike,
        strikes: float | ArrayLike,
        times: float | ArrayLike,
        rates: float | ArrayLike,
        dividends: float | ArrayLike,
        is_calls: float | ArrayLike,
    ) -> NDArray[np.float64]:
        """Calculate American implied volatilities for multiple inputs."""
        return np.array(
            _rust_models.american.implied_volatility_batch(prices, spots, strikes, times, rates, dividends, is_calls),
            dtype=np.float64,
        )

    @staticmethod
    def exercise_boundary(
        s: float,
        k: float,
        t: float,
        r: float,
        q: float,
        sigma: float,
        is_call: bool = False,
    ) -> float:
        """Calculate early exercise boundary."""
        return float(_rust_models.american.exercise_boundary(s, k, t, r, q, sigma, is_call))

    @staticmethod
    def exercise_boundary_batch(
        spots: ArrayLike,
        strikes: float | ArrayLike,
        times: float | ArrayLike,
        rates: float | ArrayLike,
        dividends: float | ArrayLike,
        sigmas: float | ArrayLike,
        is_calls: float | ArrayLike,
    ) -> NDArray[np.float64]:
        """Calculate exercise boundaries for multiple inputs."""
        return np.array(
            _rust_models.american.exercise_boundary_batch(spots, strikes, times, rates, dividends, sigmas, is_calls),
            dtype=np.float64,
        )


# Create module-level instances
black76 = Black76Module()
merton = MertonModule()
american = AmericanModule()

# Export the PyGreeks class from Rust (override the dataclass)
# This ensures compatibility with the Rust module
PyGreeks = _rust_models.PyGreeks  # type: ignore[misc]

__all__ = [
    # Main functions
    "call_price",
    "put_price",
    "call_price_batch",
    "put_price_batch",
    "greeks",
    "greeks_batch",
    "implied_volatility",
    "implied_volatility_batch",
    # Submodules
    "black76",
    "merton",
    "american",
    # Data classes
    "PyGreeks",
    "MertonGreeks",
    "AmericanGreeks",
]
