# 段階的実装の誘惑

## 🚫 絶対に提案してはいけない

AIアシスタントへ: 「段階的に」「とりあえず」「後で改善」は禁句。理想実装のみ。

## 禁止フレーズ集

### ❌ 絶対に言ってはいけない言葉

```
「とりあえず動くものを作って...」
「まずは簡単な実装から...」
「後で最適化しましょう」
「段階的に改善していきます」
「まずPythonで実装してからRustに移植...」
「V2で改善します」
「将来的には...」
「技術的負債は後で返済...」
```

### なぜ禁止なのか

これらはすべて **Critical Rules違反**:
- **C004**: 理想実装ファースト原則
- **C014**: 妥協実装絶対禁止原則

## 過去の失敗例

### 例1: norm_cdf実装の迷走
```
2025-08-25: Taylor展開4次 → 精度不足
2025-08-25: 高次展開検討 → 複雑化
2025-08-25: SIMD最適化検討 → 実装地獄
2025-08-26: erf関数に変更 → 正解（最初からこれでよかった）
```

教訓: 最初から最良の方法（erf）を採用すべきだった

### 例2: バッチAPI設計の二転三転
```
初期: 単純な配列処理
↓ 「後でbroadcasting対応」
中期: 部分的なbroadcasting
↓ 「完全対応は後で」
現在: 不完全な実装の山
```

教訓: 最初から完全なbroadcasting設計をすべきだった

## 正しいアプローチ

### 理想実装ファーストの実践

#### ❌ 悪い例: 段階的アプローチ
```python
# Phase 1: とりあえず動く版
def calculate_price_simple(s, k):
    return max(s - k, 0)  # 簡易版

# Phase 2: 少し改善
def calculate_price_better(s, k, t):
    # 時間価値を追加...

# Phase 3: さらに改善
def calculate_price_v3(s, k, t, r, sigma):
    # Black-Scholesに...

# 結果: 3つの異なる実装が混在、技術的負債の山
```

#### ✅ 良い例: 理想実装ファースト
```rust
// 最初から完全なBlack-Scholes実装
pub fn black_scholes_call(s: f64, k: f64, t: f64, r: f64, sigma: f64) -> f64 {
    // 完全な実装
    let d1 = (s.ln() - k.ln() + (r + sigma * sigma / 2.0) * t) / (sigma * t.sqrt());
    let d2 = d1 - sigma * t.sqrt();
    s * norm_cdf(d1) - k * (-r * t).exp() * norm_cdf(d2)
}
```

### 実装判断フローチャート

```
新機能の要求
    ↓
理想形は明確か？
    ↓ No
設計を完了させる（実装しない）
    ↓ Yes
必要な技術はすべて利用可能か？
    ↓ No
技術調査を完了させる（実装しない）
    ↓ Yes
一度の実装で完成できるか？
    ↓ No
スコープを縮小して完成可能な単位にする
    ↓ Yes
実装開始
```

## アンチパターンの症状

### 危険信号
- 同じ機能の複数バージョンが存在
- `_v2`、`_old`、`_legacy` サフィックス
- TODO/FIXMEコメントの蓄積
- 「暫定的に」というコメント
- 互換性レイヤーの存在

### コードの腐敗進行
```
Stage 1: 「ちょっとした回避策」
    ↓ 1週間
Stage 2: 回避策の上に機能追加
    ↓ 1ヶ月
Stage 3: 回避策が前提の設計に
    ↓ 3ヶ月
Stage 4: 完全な作り直しが必要（技術的破産）
```

## 具体的な禁止事項

### 1. プロトタイプの本番投入
```rust
// ❌ 禁止
// TODO: 後で最適化
fn quick_and_dirty_implementation() { }

// ✅ 必須
fn production_ready_implementation() { }
```

### 2. 移行パスの作成
```rust
// ❌ 禁止
trait OldAPI { }
trait NewAPI { }
struct MigrationAdapter { }  // 地獄への入り口

// ✅ 必須
trait API { }  // 唯一の実装
```

### 3. バージョン付きクラス
```rust
// ❌ 禁止
struct BlackScholes { }
struct BlackScholesV2 { }  // C013違反

// ✅ 必須
struct BlackScholes { }  // 既存を修正
```

## 例外（存在しない）

**例外は一切認めない**

よくある言い訳と反論:
- 「時間がない」→ 中途半端な実装の修正により時間がかかる
- 「要件が不明確」→ 要件を明確にしてから実装
- 「実験的機能」→ playground/で実験、本番には入れない
- 「後方互換性」→ ユーザーゼロなので不要

## チェックリスト

実装前に必ず確認:

- [ ] 理想形が完全に明確になっているか
- [ ] 必要な技術調査は完了しているか
- [ ] 一度の実装で完成できるか
- [ ] 既存コードとの重複はないか（DRY原則）
- [ ] テストを先に書いたか（TDD）
- [ ] ドキュメントと実装が一致するか

1つでも No なら **実装禁止**

## 結論

**「段階的」は「永遠に完成しない」の同義語**

常に理想実装のみ。妥協は技術的負債。
不明なら実装しない。それが最善。

## 参考資料

- Critical Rules: @.claude/critical-rules.xml (C004, C014)
- 開発原則: @.claude/development-principles.md
- プロジェクト原則: @CLAUDE.md 「段階的実装: 禁止」