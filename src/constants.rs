//! プロジェクト全体の定数定義
//!
//! QuantForgeプロジェクトで使用される共通定数を定義
//! 精度レベルは用途別に階層化されており、適切なレベルを選択して使用してください。

/// 実務精度: 価格計算・金融実務用（0.1% = 1bp×10）
///
/// 金融実務で標準的な精度。機関投資家の取引でも0.1セント単位で十分。
/// この精度は浮動小数点演算で確実に達成可能。
/// 価格計算、バッチ処理、実務アプリケーションで使用。
pub const PRACTICAL_TOLERANCE: f64 = 1e-3;

/// 理論精度: アルゴリズムの精度制約下での検証用
///
/// norm_cdf実装の現在の精度限界（約1e-5レベル）を考慮した精度。
/// 理論的な価格モデルの検証や、数学的性質のテストで使用。
pub const THEORETICAL_TOLERANCE: f64 = 1e-5;

/// 数値精度: 基本的な数値計算の検証用
///
/// 高精度が必要な数学的性質の検証（対称性、単調性など）で使用。
/// 浮動小数点演算の限界内での最高精度レベル。
pub const NUMERICAL_TOLERANCE: f64 = 1e-7;

/// デフォルト精度（実務用途）
///
/// 後方互換性のため、EPSILONは実務精度を指す。
/// 新規コードではPRACTICAL_TOLERANCEの使用を推奨。
pub const EPSILON: f64 = PRACTICAL_TOLERANCE;

/// 数学定数: 1/√(2π)
///
/// 標準正規分布の確率密度関数で使用。
/// 値は高精度計算により導出。
pub const INV_SQRT_2PI: f64 = 0.3989422804014327;

/// グリークス計算用: 年間日数
///
/// Theta計算で1日あたりの時間価値減少を計算する際に使用。
/// 金融実務では365日を標準とする。
pub const DAYS_PER_YEAR: f64 = 365.0;

/// グリークス計算用: ベーシスポイント
///
/// VegaとRhoの計算で1%変化に対する感応度を表現する際に使用。
/// 1% = 100ベーシスポイント
pub const BASIS_POINT_MULTIPLIER: f64 = 100.0;

// ============================================================================
// インプライドボラティリティ計算定数
// ============================================================================

/// IV計算: 最大反復回数
///
/// Newton-Raphson法およびBrent法での最大反復回数。
/// 通常3-5回で収束するが、エッジケースを考慮して20回に設定。
pub const IV_MAX_ITERATIONS: usize = 20;

/// IV計算: 価格収束判定閾値
///
/// 計算された価格と市場価格の差がこの値以下なら収束とみなす。
/// 金融実務での価格精度を考慮した値。
pub const IV_TOLERANCE_PRICE: f64 = 1e-9;

/// IV計算: ボラティリティ収束判定閾値
///
/// 連続する反復でのボラティリティ変化がこの値以下なら収束とみなす。
pub const IV_TOLERANCE_VOL: f64 = 1e-6;

/// IV計算: 最小ボラティリティ（0.1%）
///
/// 市場で観測される実質的な最小ボラティリティ。
/// これ以下の値は非現実的とみなす。
pub const IV_MIN_VOL: f64 = 0.001;

/// IV計算: 最大ボラティリティ（500%）
///
/// 市場で観測される実質的な最大ボラティリティ。
/// 暗号通貨等の極端なケースを考慮。
pub const IV_MAX_VOL: f64 = 5.0;

/// IV計算: Vega最小閾値（数値安定性）
///
/// Newton-Raphson法でVegaがこの値以下の場合、数値的に不安定とみなす。
/// ゼロ除算を避けるための安全閾値。
pub const VEGA_MIN_THRESHOLD: f64 = 1e-10;

/// IV計算: 初期ブラケット幅
///
/// Brent法での初期探索範囲の幅。
/// 初期推定値の周辺をこの幅で探索。
pub const IV_INITIAL_BRACKET_WIDTH: f64 = 0.5;

/// Newton法: 最大試行回数
///
/// Newton-Raphson法での最大試行回数。
/// これを超えたらBrent法にフォールバック。
pub const NEWTON_MAX_ATTEMPTS: usize = 7;

/// Brent法: 最大反復回数
///
/// Brent法での最大反復回数。
/// 収束が保証されているが、念のため上限を設定。
pub const BRENT_MAX_ITERATIONS: usize = 50;

// ============================================================================
// Bjerksund-Stensland 2002モデル定数
// ============================================================================

/// BS2002: βパラメータ最小値
///
/// Bjerksund-Stensland 2002モデルでのβパラメータの下限値。
/// モデルの数値的安定性を保証するための制約。
pub const BS2002_BETA_MIN: f64 = 0.5;

/// BS2002: 収束判定閾値
///
/// Bjerksund-Stensland 2002モデルでの反復計算の収束判定に使用。
/// 早期行使境界の計算等で使用。
pub const BS2002_CONVERGENCE_TOL: f64 = 1e-9;

/// 早期行使境界: 最大反復回数
///
/// 早期行使境界を求める反復法での最大反復回数。
/// 通常5-10回で収束するが、余裕を持たせて20回に設定。
pub const EXERCISE_BOUNDARY_MAX_ITER: usize = 20;

/// BS2002: h(T)計算係数
///
/// Bjerksund-Stensland 2002モデルでのh(T)関数の係数。
/// 早期行使境界の時間依存性を表現する重要なパラメータ。
pub const BS2002_H_FACTOR: f64 = 2.0;

// ============================================================================
// パフォーマンス最適化定数
// ============================================================================

/// キャッシュライン・サイズ（バイト）
///
/// 現代のx86_64プロセッサの標準的なキャッシュラインサイズ。
/// データアラインメントとパディングに使用。
pub const CACHE_LINE_SIZE: usize = 64;

/// L1キャッシュサイズ（バイト）
///
/// 典型的なプロセッサのL1データキャッシュサイズ。
/// 最高速のアクセスが可能なデータサイズ。
pub const L1_CACHE_SIZE: usize = 32 * 1024; // 32KB

/// L2キャッシュサイズ（バイト）
///
/// 典型的なプロセッサのL2キャッシュサイズ。
/// L1より大きいが、依然として高速アクセス可能。
pub const L2_CACHE_SIZE: usize = 256 * 1024; // 256KB

/// L3キャッシュサイズ（バイト）
///
/// 典型的なプロセッサのL3キャッシュサイズ。
/// 複数コア間で共有される最終レベルキャッシュ。
pub const L3_CACHE_SIZE: usize = 8 * 1024 * 1024; // 8MB

/// チャンクサイズ: L1キャッシュ最適化
///
/// L1キャッシュに収まるf64要素数。
/// 最高速の処理が可能なチャンクサイズ。
pub const CHUNK_SIZE_L1: usize = L1_CACHE_SIZE / 8 / 4; // 1024要素 (4-way split)

/// チャンクサイズ: L2キャッシュ最適化
///
/// L2キャッシュに収まるf64要素数。
/// 中規模データの効率的な処理に使用。
pub const CHUNK_SIZE_L2: usize = L2_CACHE_SIZE / 8 / 4; // 8192要素

/// チャンクサイズ: L3キャッシュ最適化
///
/// L3キャッシュに収まるf64要素数。
/// 大規模データの並列処理時のチャンクサイズ。
pub const CHUNK_SIZE_L3: usize = L3_CACHE_SIZE / 8 / 4; // 262144要素

/// 並列化閾値: 小規模
///
/// この要素数以下ではシーケンシャル処理が高速。
/// FFIオーバーヘッドと並列化コストを考慮。
/// 実測値に基づき、10,000要素でNumPyと同等になるよう調整。
pub const PARALLEL_THRESHOLD_SMALL: usize = 30_000;

/// 並列化閾値: 中規模
///
/// この要素数以上で並列化が有効になり始める。
/// スレッドプール起動のオーバーヘッドを考慮。
pub const PARALLEL_THRESHOLD_MEDIUM: usize = 200_000;

/// 並列化閾値: 大規模
///
/// この要素数以上で積極的な並列化が有効。
/// 全CPUコアを活用した処理を行う。
pub const PARALLEL_THRESHOLD_LARGE: usize = 1_000_000;

/// スレッドあたり最小ワークロード
///
/// 並列化時の各スレッドが処理する最小要素数。
/// これ以下では並列化のオーバーヘッドが大きすぎる。
pub const MIN_WORK_PER_THREAD: usize = 1000;

/// 最大並列度
///
/// 同時に使用する最大スレッド数。
/// システムのCPUコア数に基づいて動的に調整。
pub const MAX_PARALLELISM: usize = 32;

/// SIMDアラインメント（バイト）
///
/// AVX2命令セット用のメモリアラインメント。
/// 32バイト境界にアラインすることで最高性能を実現。
pub const SIMD_ALIGNMENT: usize = 32;

/// プリフェッチ距離（要素数）
///
/// CPUプリフェッチのための先読み距離。
/// 現在処理中の要素からこの数だけ先のデータをプリフェッチ。
pub const PREFETCH_DISTANCE: usize = 8;
